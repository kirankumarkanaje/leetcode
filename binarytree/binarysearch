Problem: Binary Search (search in sorted array)
Pattern: Binary Search
Core idea in 1 sentence: Repeatedly cut the search range in half by comparing target with the middle element.
Key invariant: target (if it exists) is always within the current search interval [l, r].
Common pitfall: Off-by-one updates (l = mid / r = mid) causing an infinite loop; always move to mid ± 1.
Pseudocode (5 lines max):
  l=0, r=n-1
  while l <= r: mid = l + (r-l)//2
    if nums[mid] == target: return mid
    else if nums[mid] < target: l = mid + 1
    else: r = mid - 1; return -1

Complexity: Time O(log n), Space O(1)
Why this complexity:
Each loop step eliminates half the remaining search space (because the array is sorted, you can discard either the left half or the right half).
Halving n repeatedly takes about log2(n) steps until the range becomes empty or you find the target → O(log n) time.
You only store a few variables (l, r, mid) and don’t allocate extra arrays/recursion stack → O(1) space.

Code:

class Solution:
    def search(self, nums: List[int], target: int) -> int:

        #optimized
        l = 0
        r = len(nums) - 1
        while l <= r:
            mid = l + (r - l) // 2 #pitfall
            if nums[mid] == target :
                return mid
            elif nums[mid] < target:
                l = mid + 1 #pitfall
            else:
                r = mid - 1 #pitfall
        return - 1

        #brute force O(n)
        '''for i in range(len(nums) - 1):
            if nums[i] == target:
                return i
        
        return -1
        '''
