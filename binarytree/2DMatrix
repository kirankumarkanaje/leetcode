Problem: Search a 2D Matrix
Pattern: Binary Search (2-phase: row selection + in-row search)
Core idea in 1 sentence: First binary search to find the only possible row that could contain target, then binary search within that row.
Key invariant: After the row-search, if top <= bottom, then target must lie within matrix[row][0]..matrix[row][-1] for the chosen row; during each binary search, target (if present) stays within the current [l, r] interval.
Common pitfall: Using column bounds for the row search (bottom = COL-1) or forgetting the “row not found” check (if top > bottom: return False), and incorrect mid-to-bounds updates causing infinite loops.

Pseudocode (5 lines max):
top=0, bot=ROWS-1
while top<=bot: row=(top+bot)//2; adjust by comparing target with row’s first/last
if top>bot: return False
binary search in matrix[row] from l=0..COLS-1
return True if found else False

Complexity: Time O(log ROWS + log COLS) = O(log(ROWS*COLS)), Space O(1)

Code:

class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:

        #optimized

        ROW = len(matrix)
        COL = len(matrix[0])
        top = 0
        bottom = ROW - 1

        while top <= bottom:
            row = (top + bottom) // 2
            if target > matrix[row][-1]:
                top = row + 1
            elif target < matrix[row][0]:
                bottom = row - 1
            else:
                break
        
        if top > bottom:
            return False

        row = (top + bottom) // 2

        l = 0
        r = COL - 1
        while l <= r:
            mid = l + (r - l) // 2
            if matrix[row][mid] == target:
                return True
            if target > matrix[row][mid]:
                l = mid + 1
            else:
                r = mid - 1

        return False


        #brute force
        '''for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if target == matrix[i][j]:
                    return True
        return False
        '''
